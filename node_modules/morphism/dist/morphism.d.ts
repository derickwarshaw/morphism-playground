/**
 * A String path that indicates where to find the property in the source input
 *
 * @example
 * ```typescript
 *
 * const source = {
 *   foo: 'baz',
 *   bar: ['bar', 'foo'],
 *   baz: {
 *     qux: 'bazqux'
 *   }
 * };
 * const schema = {
 *   foo: 'foo', // Simple Projection
 *   bazqux: 'baz.qux' // Grab a value from a nested property
 * };
 *
 * morphism(schema, source);
 * //=> { foo: 'baz', bazqux: 'bazqux' }
 * ```
 *
 */
export declare type ActionString = string;
export declare type ActionFunction = {
    /**
     * A Function invoked per iteration
     * @param {} iteratee The current element to transform
     * @param source The source input to transform
     * @param target The current element transformed
     * @example
     * ```typescript
     *
     * const source = {
     *   foo: {
     *     bar: 'bar'
     *   }
     * };
     * let schema = {
     *   bar: iteratee => {
     *     // Apply a function over the source propery
     *     return iteratee.foo.bar;
     *   }
     * };
     *
     * morphism(schema, source);
     * //=> { bar: 'bar' }
     * ```
     *
     */
    (iteratee: any, source: any | any[], target: any): any;
};
/**
 * An Array of String that allows to perform a function over source property
 *
 * @example
 * ```typescript
 *
 * const source = {
 *   foo: 'foo',
 *   bar: 'bar'
 * };
 * let schema = {
 *   fooAndBar: ['foo', 'bar'] // Grab these properties into fooAndBar
 * };
 *
 * morphism(schema, source);
 * //=> { fooAndBar: { foo: 'foo', bar: 'bar' } }
 * ```
 */
export declare type ActionAggregator = string[];
/**
 * An Object that allows to perform a function over a source property's value
 *
 * @example
 * ```typescript
 *
 * const source = {
 *   foo: {
 *     bar: 'bar'
 *   }
 * };
 * let schema = {
 *   barqux: {
 *     path: 'foo.bar',
 *     fn: value => `${value}qux` // Apply a function over the source property's value
 *   }
 * };
 *
 * morphism(schema, source);
 * //=> { barqux: 'barqux' }
 *```
 *
 */
export declare type ActionSelector = {
    path: string | string[];
    fn: (fieldValue: any, items: any[]) => any;
};
export declare type StrictSchema<Target> = {
    [destinationProperty in keyof Target]: ActionString | ActionFunction | ActionAggregator | ActionSelector;
};
export declare type Schema<Target> = {
    [destinationProperty in keyof Target]?: ActionString | ActionFunction | ActionAggregator | ActionSelector;
};
interface Constructable<T> {
    new (...args: any[]): T;
}
interface Mapper<Target> {
    <Source>(source: Source[]): Target[];
    <Source>(source: Source): Target;
}
/**
 * Currying function that either outputs a mapping function or the transformed data.
 *
 * @example
 * ```js
 *
  // => Outputs a function when only a schema is provided
  const fn = morphism(schema);
  const result = fn(data);

  // => Outputs the transformed data when a schema and the input data is provided
  const result = morphism(schema, data);

  // => Outputs the transformed data as an ES6 Class Object when a schema, the input data and an ES6 Class are provided
  const result = morphism(schema, data, Foo);
  // result is type of Foo
 * ```
 * @param  {Schema} schema Structure-preserving object from a source data towards a target data
 * @param  {} items Object or Collection to be mapped
 * @param  {} type
 *
 */
export declare function morphism<TSchema extends Schema<any>>(schema: TSchema, items: any[]): {
    [P in keyof TSchema]: any;
}[];
export declare function morphism<TSchema extends Schema<any>>(schema: TSchema, items: any): {
    [P in keyof TSchema]: any;
};
export declare function morphism<Target>(schema: Schema<Target>, items: any[]): Target[];
export declare function morphism<Target>(schema: Schema<Target>, items: any): Target;
export declare function morphism<TSchema extends Schema<any>>(schema: TSchema): Mapper<{
    [P in keyof TSchema]: any;
}>;
export declare function morphism<Target>(schema: Schema<Target>): Mapper<Target>;
export declare function morphism(schema: Schema<any>, items: null): undefined;
export declare function morphism(schema: null, items: {}): undefined;
export declare function morphism<Target, Source>(schema: Schema<Target>, items: null, type: Constructable<Target>): Mapper<Target>;
export declare function morphism<Target, Source>(schema: Schema<Target>, items: Source[], type: Constructable<Target>): Target[];
export declare function morphism<Target, Source>(schema: Schema<Target>, items: Source, type: Constructable<Target>): Target;
export interface IMorphismRegistry {
    /**
     * Register a mapping schema for a Class.
     *
     * @param type Class Type to be registered
     * @param schema Structure-preserving object from a source data towards a target data.
     *
     */
    register<Target, TSchema extends Schema<Target>>(type: Constructable<Target>, schema?: TSchema): Mapper<Target>;
    /**
     * Transform any input in the specified Class
     *
     * @param {Type} type Class Type of the ouput Data
     * @param {Object} data Input data to transform
     *
     */
    map<Target>(type: Target): Mapper<Target>;
    map<Target, Source>(type: Constructable<Target>, data: Source[]): Target[];
    map<Target, Source>(type: Constructable<Target>, data: Source): Target;
    /**
     * Get a specific mapping function for the provided Class
     *
     * @param {Type} type Class Type of the ouput Data
     *
     */
    getMapper<Target>(type: Constructable<Target>): Mapper<Target>;
    /**
     * Set a schema for a specific Class Type
     *
     * @param {Type} type Class Type of the ouput Data
     * @param {Schema} schema Class Type of the ouput Data
     *
     */
    setMapper<Target, TSchema extends Schema<Target>>(type: Constructable<Target>, schema: TSchema): Mapper<Target>;
    /**
     * Delete a registered schema associated to a Class
     *
     * @param type ES6 Class Type of the ouput Data
     *
     */
    deleteMapper<Target>(type: Constructable<Target>): any;
    /**
     * Check if a schema has already been registered for this type
     *
     * @param {*} type
     */
    exists<Target>(type: Target): boolean;
    /**
     * Get the list of the mapping functions registered
     *
     * @param {Type} type Class Type of the ouput Data
     *
     */
    mappers: Map<any, any>;
}
export declare class MorphismRegistry implements IMorphismRegistry {
    private _registry;
    /**
     *Creates an instance of MorphismRegistry.
     * @param {Map<any, any>} cache Cache implementation to store the mapping functions.
     */
    constructor(cache?: Map<any, any> | WeakMap<any, any>);
    /**
     * Register a mapping schema for a Class.
     *
     * @param type Class Type to be registered
     * @param schema Structure-preserving object from a source data towards a target data.
     *
     */
    register<Target, TSchema extends Schema<Target>>(type: Constructable<Target>, schema?: TSchema): Mapper<Target>;
    /**
     * Transform any input in the specified Class
     *
     * @param {Type} type Class Type of the ouput Data
     * @param {Object} data Input data to transform
     *
     */
    map(type: any, data?: any): any;
    /**
     * Get a specific mapping function for the provided Class
     *
     * @param {Type} type Class Type of the ouput Data
     *
     */
    getMapper<Target>(type: Constructable<Target>): any;
    /**
     * Set a schema for a specific Class Type
     *
     * @param {Type} type Class Type of the ouput Data
     * @param {Schema} schema Class Type of the ouput Data
     *
     */
    setMapper<Target>(type: Constructable<Target>, schema: Schema<Target>): Mapper<Target>;
    /**
     * Delete a registered schema associated to a Class
     *
     * @param type ES6 Class Type of the ouput Data
     *
     */
    deleteMapper(type: any): any;
    /**
     * Check if a schema has already been registered for this type
     *
     * @param {*} type
     */
    exists(type: any): any;
    /**
     * Get the list of the mapping functions registered
     *
     * @param {Type} type Class Type of the ouput Data
     *
     */
    readonly mappers: Map<any, any>;
}
/**
 * Function Decorator transforming the return value of the targeted Function using the provided Schema and/or Type
 *
 * @param {Schema<Target>} schema Structure-preserving object from a source data towards a target data
 * @param {Constructable<Target>} [type] Target Class Type
 */
export declare function morph<Target>(schema: Schema<Target>, type?: Constructable<Target>): (target: any, name: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
/**
 * Function Decorator transforming the return value of the targeted Function to JS Object(s) using the provided Schema
 *
 * @param {StrictSchema<Target>} schema Structure-preserving object from a source data towards a target data
 */
export declare function toJSObject<Target>(schema: StrictSchema<Target>): (target: any, name: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
/**
 * Function Decorator transforming the return value of the targeted Function using the provided Schema and Class Type
 *
 * @param {Schema<Target>} schema Structure-preserving object from a source data towards a target data
 * @param {Constructable<Target>} [type] Target Class Type
 */
export declare function toClassObject<Target>(schema: Schema<Target>, type: Constructable<Target>): (target: any, name: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
declare const Morphism: typeof morphism & IMorphismRegistry;
export default Morphism;
