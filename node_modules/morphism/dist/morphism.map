{"version":3,"sources":["file:///webpack/bootstrap","file:////home/circleci/repo/src/morphism.ts","file:////home/circleci/repo/src/helpers.ts"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","helpers_1","transformValuesFromObject","schema","items","objectToCompute","entries","map","_a","_b","__read","targetProperty","action","isString","_c","isFunction","_d","undefined","Array","isArray","_e","aggregator","isObject","result","path","fn","e","message","_f","reduce","finalObject","keyValue","assignInWith","destination","source","isUndefined","transformItems","type","obj","classObject","getSchemaForType","baseSchema","typeFields","keys","defaultSchema","zipObject","assign","morphism","finalSchema_1","futureInput","MorphismRegistry","cache","this","_registry","Map","register","Error","exists","mapper","set","data","getMapper","setMapper","deleteMapper","delete","has","decorator","target","descriptor","args","_i","arguments","length","output","apply","Promise","resolve","isPromise","then","res","morph","toJSObject","toClassObject","morphismRegistry","morphismMixin","mappers","Morphism","default","paths","replace","split","lastProperty","pop","finalValue","reduceRight","prop","__assign","a","k","delta","customizer","forEach","field","String","props","values","prev"],"mappings":"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","file":"morphism.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/**\n * @module morphism\n */\nimport { isString, get, isFunction, isObject, zipObject, isUndefined, assignInWith, aggregator } from './helpers';\n\n/**\n * A String path that indicates where to find the property in the source input\n *\n * @example\n * ```typescript\n *\n * const source = {\n *   foo: 'baz',\n *   bar: ['bar', 'foo'],\n *   baz: {\n *     qux: 'bazqux'\n *   }\n * };\n * const schema = {\n *   foo: 'foo', // Simple Projection\n *   bazqux: 'baz.qux' // Grab a value from a nested property\n * };\n *\n * morphism(schema, source);\n * //=> { foo: 'baz', bazqux: 'bazqux' }\n * ```\n *\n */\nexport type ActionString = string;\nexport type ActionFunction = {\n  /**\n   * A Function invoked per iteration\n   * @param {} iteratee The current element to transform\n   * @param source The source input to transform\n   * @param target The current element transformed\n   * @example\n   * ```typescript\n   *\n   * const source = {\n   *   foo: {\n   *     bar: 'bar'\n   *   }\n   * };\n   * let schema = {\n   *   bar: iteratee => {\n   *     // Apply a function over the source propery\n   *     return iteratee.foo.bar;\n   *   }\n   * };\n   *\n   * morphism(schema, source);\n   * //=> { bar: 'bar' }\n   * ```\n   *\n   */\n  (iteratee: any, source: any | any[], target: any): any;\n};\n/**\n * An Array of String that allows to perform a function over source property\n *\n * @example\n * ```typescript\n *\n * const source = {\n *   foo: 'foo',\n *   bar: 'bar'\n * };\n * let schema = {\n *   fooAndBar: ['foo', 'bar'] // Grab these properties into fooAndBar\n * };\n *\n * morphism(schema, source);\n * //=> { fooAndBar: { foo: 'foo', bar: 'bar' } }\n * ```\n */\nexport type ActionAggregator = string[];\n/**\n * An Object that allows to perform a function over a source property's value\n *\n * @example\n * ```typescript\n *\n * const source = {\n *   foo: {\n *     bar: 'bar'\n *   }\n * };\n * let schema = {\n *   barqux: {\n *     path: 'foo.bar',\n *     fn: value => `${value}qux` // Apply a function over the source property's value\n *   }\n * };\n *\n * morphism(schema, source);\n * //=> { barqux: 'barqux' }\n *```\n *\n */\nexport type ActionSelector = { path: string | string[]; fn: (fieldValue: any, items: any[]) => any };\n\n/**\n * A structure-preserving object from a source data towards a target data.\n *\n * The keys of the schema match the desired destination structure.\n * Each value corresponds to an Action applied by Morphism when iterating over the input data\n * @example\n * ```typescript\n *\n * const input = {\n *   foo: {\n *     baz: 'value1'\n *   }\n * };\n *\n * const schema: Schema = {\n *   bar: 'foo', // ActionString\n *   qux: ['foo', 'foo.baz'], // ActionAggregator\n *   quux: (iteratee, source, destination) => { // ActionFunction\n *     return iteratee.foo;\n *   },\n *   corge: { // ActionSelector\n *     path: 'foo.baz',\n *     fn: (propertyValue, source) => {\n *       return propertyValue;\n *     }\n *   }\n * };\n *\n * morphism(schema, input);\n * ```\n */\ntype SchemaActions = ActionString | ActionFunction | ActionAggregator | ActionSelector;\nexport type StrictSchema<Target> = {\n  /** `destinationProperty` is the name of the property of the target object you want to produce */\n  [destinationProperty in keyof Target]: ActionString | ActionFunction | ActionAggregator | ActionSelector\n};\nexport type Schema<Target> = {\n  /** `destinationProperty` is the name of the property of the target object you want to produce */\n  [destinationProperty in keyof Target]?: ActionString | ActionFunction | ActionAggregator | ActionSelector\n};\n\nfunction transformValuesFromObject<TDestination, Source>(\n  object: Source,\n  schema: Schema<TDestination>,\n  items: Source[],\n  objectToCompute: TDestination\n): TDestination;\n/**\n * Low Level transformer function.\n * Take a plain object as input and transform its values using a specified schema.\n * @param  {Object} object\n * @param  {Map<string, string> | Map<string, Function>} schema Transformation schema\n * @param  {Array} items Items to be forwarded to Actions\n * @param  {} objectToCompute Created tranformed object of a given type\n */\nfunction transformValuesFromObject<TDestination, Source>(\n  object: Source,\n  schema: Schema<TDestination>,\n  items: Source[],\n  objectToCompute: TDestination\n) {\n  return Object.entries(schema)\n    .map(([targetProperty, action]: [string, SchemaActions]) => {\n      // iterate on every action of the schema\n      if (isString(action)) {\n        // Action<String>: string path => [ target: 'source' ]\n        return { [targetProperty]: get(object, action) };\n      } else if (isFunction(action)) {\n        // Action<Function>: Free Computin - a callback called with the current object and collection [ destination: (object) => {...} ]\n        return { [targetProperty]: action.call(undefined, object, items, objectToCompute) };\n      } else if (Array.isArray(action)) {\n        // Action<Array>: Aggregator - string paths => : [ destination: ['source1', 'source2', 'source3'] ]\n        return { [targetProperty]: aggregator(action, object) };\n      } else if (isObject(action)) {\n        // Action<Object>: a path and a function: [ destination : { path: 'source', fn:(fieldValue, items) }]\n        let result;\n        try {\n          let value;\n          if (Array.isArray(action.path)) {\n            value = aggregator(action.path, object);\n          } else if (isString(action.path)) {\n            value = get(object, action.path);\n          }\n          result = action.fn.call(undefined, value, object, items, objectToCompute);\n        } catch (e) {\n          e.message = `Unable to set target property [${targetProperty}].\n                                \\n An error occured when applying [${action.fn.name}] on property [${action.path}]\n                                \\n Internal error: ${e.message}`;\n          throw e;\n        }\n\n        return { [targetProperty]: result };\n      }\n    })\n    .reduce((finalObject, keyValue) => {\n      const undefinedValueCheck = (destination: any, source: any) => {\n        // Take the Object class value property if the incoming property is undefined\n        if (isUndefined(source)) {\n          if (!isUndefined(destination)) {\n            return destination;\n          } else {\n            return; // No Black Magic Fuckery here, if the source and the destination are undefined, we don't do anything\n          }\n        } else {\n          return source;\n        }\n      };\n      return assignInWith(finalObject, keyValue, undefinedValueCheck);\n    }, objectToCompute);\n}\ninterface Constructable<T> {\n  new (...args: any[]): T;\n}\n\ninterface Mapper<Target> {\n  <Source>(source: Source[]): Target[];\n  <Source>(source: Source): Target;\n}\n\nfunction transformItems<T, TSchema extends Schema<T>>(schema: TSchema): Mapper<{ [P in keyof TSchema]: any }>;\nfunction transformItems<T, TSchema extends Schema<T>>(schema: TSchema, type: Constructable<T>): Mapper<{ [P in keyof TSchema]: any }>;\n\nfunction transformItems<T, TSchema extends Schema<T>>(schema: TSchema, type?: Constructable<T>) {\n  function mapper(source: any): any {\n    if (!source) {\n      return source;\n    }\n    if (Array.isArray(source)) {\n      return source.map(obj => {\n        if (type) {\n          const classObject = new type();\n          return transformValuesFromObject(obj, schema, source, classObject);\n        } else {\n          const jsObject = {};\n          return transformValuesFromObject(obj, schema, source, jsObject);\n        }\n      });\n    } else {\n      const object = source;\n      if (type) {\n        const classObject = new type();\n        return transformValuesFromObject(object, schema, [object], classObject);\n      } else {\n        const jsObject = {};\n        return transformValuesFromObject(object, schema, [object], jsObject);\n      }\n    }\n  }\n\n  return mapper;\n}\n\nfunction getSchemaForType<T>(type: Constructable<T>, baseSchema: Schema<T>): Schema<T> {\n  let typeFields = Object.keys(new type());\n  let defaultSchema = zipObject(typeFields, typeFields);\n  let finalSchema = Object.assign(defaultSchema, baseSchema);\n  return finalSchema;\n}\n\n/**\n * Currying function that either outputs a mapping function or the transformed data.\n *\n * @example\n * ```js\n *\n  // => Outputs a function when only a schema is provided\n  const fn = morphism(schema);\n  const result = fn(data);\n\n  // => Outputs the transformed data when a schema and the input data is provided\n  const result = morphism(schema, data);\n\n  // => Outputs the transformed data as an ES6 Class Object when a schema, the input data and an ES6 Class are provided\n  const result = morphism(schema, data, Foo);\n  // result is type of Foo\n * ```\n * @param  {Schema} schema Structure-preserving object from a source data towards a target data\n * @param  {} items Object or Collection to be mapped\n * @param  {} type\n *\n */\nexport function morphism<TSchema extends Schema<any>>(schema: TSchema, items: any[]): { [P in keyof TSchema]: any }[]; // morphism<Target>({},[]) => {}[]\nexport function morphism<TSchema extends Schema<any>>(schema: TSchema, items: any): { [P in keyof TSchema]: any }; // morphism({},{}) => {}\n\nexport function morphism<Target>(schema: Schema<Target>, items: any[]): Target[]; // morphism<Target>({},[]) => Target[]\nexport function morphism<Target>(schema: Schema<Target>, items: any): Target; // morphism<Target>({},{}) => Target\n\nexport function morphism<TSchema extends Schema<any>>(schema: TSchema): Mapper<{ [P in keyof TSchema]: any }>; // morphism(TSchema) => mapper(S[]) => (keyof TSchema)[]\n\nexport function morphism<Target>(schema: Schema<Target>): Mapper<Target>; // morphism<ITarget>({}) => Mapper<ITarget> => ITarget\n\nexport function morphism(schema: Schema<any>, items: null): undefined; // Reflects a specific use case where Morphism({}, null) return undefined\nexport function morphism(schema: null, items: {}): undefined; // Reflects a specific use case where Morphism(null, {}) return undefined\n\nexport function morphism<Target, Source>(schema: Schema<Target>, items: null, type: Constructable<Target>): Mapper<Target>; // morphism({}, null, T) => mapper(S) => T\nexport function morphism<Target, Source>(schema: Schema<Target>, items: Source[], type: Constructable<Target>): Target[]; // morphism({}, [], T) => T[]\nexport function morphism<Target, Source>(schema: Schema<Target>, items: Source, type: Constructable<Target>): Target; // morphism({}, {}, T) => T\n\nexport function morphism<Target, Source>(schema: Schema<Target>, items?: Source, type?: Constructable<Target>) {\n  if (items === undefined && type === undefined) {\n    return transformItems(schema);\n  } else if (schema && items && type) {\n    let finalSchema = getSchemaForType(type, schema);\n    return transformItems(finalSchema, type)(items);\n  } else if (schema && items) {\n    return transformItems(schema)(items);\n  } else if (type && items) {\n    let finalSchema = getSchemaForType(type, schema);\n    return transformItems(finalSchema, type)(items);\n  } else if (type) {\n    let finalSchema = getSchemaForType(type, schema);\n    return (futureInput: any) => {\n      return transformItems(finalSchema, type)(futureInput);\n    };\n  }\n}\n\nexport interface IMorphismRegistry {\n  /**\n   * Register a mapping schema for a Class.\n   *\n   * @param type Class Type to be registered\n   * @param schema Structure-preserving object from a source data towards a target data.\n   *\n   */\n  register<Target, TSchema extends Schema<Target>>(type: Constructable<Target>, schema?: TSchema): Mapper<Target>;\n  /**\n   * Transform any input in the specified Class\n   *\n   * @param {Type} type Class Type of the ouput Data\n   * @param {Object} data Input data to transform\n   *\n   */\n  map<Target>(type: Target): Mapper<Target>;\n  map<Target, Source>(type: Constructable<Target>, data: Source[]): Target[];\n  map<Target, Source>(type: Constructable<Target>, data: Source): Target;\n  /**\n   * Get a specific mapping function for the provided Class\n   *\n   * @param {Type} type Class Type of the ouput Data\n   *\n   */\n  getMapper<Target>(type: Constructable<Target>): Mapper<Target>;\n  /**\n   * Set a schema for a specific Class Type\n   *\n   * @param {Type} type Class Type of the ouput Data\n   * @param {Schema} schema Class Type of the ouput Data\n   *\n   */\n  setMapper<Target, TSchema extends Schema<Target>>(type: Constructable<Target>, schema: TSchema): Mapper<Target>;\n  /**\n   * Delete a registered schema associated to a Class\n   *\n   * @param type ES6 Class Type of the ouput Data\n   *\n   */\n  deleteMapper<Target>(type: Constructable<Target>): any;\n  /**\n   * Check if a schema has already been registered for this type\n   *\n   * @param {*} type\n   */\n  exists<Target>(type: Target): boolean;\n  /**\n   * Get the list of the mapping functions registered\n   *\n   * @param {Type} type Class Type of the ouput Data\n   *\n   */\n  mappers: Map<any, any>;\n}\n\nexport class MorphismRegistry implements IMorphismRegistry {\n  private _registry: any = null;\n  /**\n   *Creates an instance of MorphismRegistry.\n   * @param {Map<any, any>} cache Cache implementation to store the mapping functions.\n   */\n  constructor(cache?: Map<any, any> | WeakMap<any, any>) {\n    if (!cache) {\n      this._registry = { cache: new Map() };\n    } else {\n      this._registry = cache;\n    }\n  }\n\n  /**\n   * Register a mapping schema for a Class.\n   *\n   * @param type Class Type to be registered\n   * @param schema Structure-preserving object from a source data towards a target data.\n   *\n   */\n  register<Target, TSchema extends Schema<Target>>(type: Constructable<Target>, schema?: TSchema) {\n    if (!type && !schema) {\n      throw new Error('type paramater is required when register a mapping');\n    } else if (this.exists(type)) {\n      throw new Error(`A mapper for ${type.name} has already been registered`);\n    }\n    const mapper = morphism(schema, null, type);\n    this._registry.cache.set(type, mapper);\n    return mapper;\n  }\n  /**\n   * Transform any input in the specified Class\n   *\n   * @param {Type} type Class Type of the ouput Data\n   * @param {Object} data Input data to transform\n   *\n   */\n  map(type: any, data?: any) {\n    if (!this.exists(type)) {\n      const mapper = this.register(type);\n      if (data === undefined) {\n        return mapper;\n      }\n    }\n    return this.getMapper(type)(data);\n  }\n  /**\n   * Get a specific mapping function for the provided Class\n   *\n   * @param {Type} type Class Type of the ouput Data\n   *\n   */\n  getMapper<Target>(type: Constructable<Target>) {\n    return this._registry.cache.get(type);\n  }\n  /**\n   * Set a schema for a specific Class Type\n   *\n   * @param {Type} type Class Type of the ouput Data\n   * @param {Schema} schema Class Type of the ouput Data\n   *\n   */\n  setMapper<Target>(type: Constructable<Target>, schema: Schema<Target>) {\n    if (!schema) {\n      throw new Error(`The schema must be an Object. Found ${schema}`);\n    } else if (!this.exists(type)) {\n      throw new Error(`The type ${type.name} is not registered. Register it using \\`Mophism.register(${type.name}, schema)\\``);\n    } else {\n      let fn = morphism(schema, null, type);\n      this._registry.cache.set(type, fn);\n      return fn;\n    }\n  }\n\n  /**\n   * Delete a registered schema associated to a Class\n   *\n   * @param type ES6 Class Type of the ouput Data\n   *\n   */\n  deleteMapper(type: any) {\n    return this._registry.cache.delete(type);\n  }\n\n  /**\n   * Check if a schema has already been registered for this type\n   *\n   * @param {*} type\n   */\n  exists(type: any) {\n    return this._registry.cache.has(type);\n  }\n  /**\n   * Get the list of the mapping functions registered\n   *\n   * @param {Type} type Class Type of the ouput Data\n   *\n   */\n  get mappers() {\n    return this._registry.cache as Map<any, any>;\n  }\n}\n\nfunction decorator<Target>(mapper: Mapper<Target>) {\n  return (target: any, name: string, descriptor: PropertyDescriptor) => {\n    const fn = descriptor.value;\n    if (typeof fn === 'function') {\n      descriptor.value = function(...args: any[]) {\n        const output = fn.apply(this, args);\n        if (isPromise(output)) {\n          return Promise.resolve(output).then(res => mapper(res));\n        }\n        return mapper(output);\n      };\n    }\n\n    return descriptor;\n  };\n}\nfunction isPromise(object: any) {\n  if (Promise && Promise.resolve) {\n    return Promise.resolve(object) == object;\n  } else {\n    throw 'Promise not supported in your environment';\n  }\n}\n\n/**\n * Function Decorator transforming the return value of the targeted Function using the provided Schema and/or Type\n *\n * @param {Schema<Target>} schema Structure-preserving object from a source data towards a target data\n * @param {Constructable<Target>} [type] Target Class Type\n */\nexport function morph<Target>(schema: Schema<Target>, type?: Constructable<Target>) {\n  const mapper = transformItems(schema, type);\n  return decorator(mapper);\n}\n/**\n * Function Decorator transforming the return value of the targeted Function to JS Object(s) using the provided Schema\n *\n * @param {StrictSchema<Target>} schema Structure-preserving object from a source data towards a target data\n */\nexport function toJSObject<Target>(schema: StrictSchema<Target>) {\n  const mapper = transformItems(schema);\n  return decorator(mapper);\n}\n/**\n * Function Decorator transforming the return value of the targeted Function using the provided Schema and Class Type\n *\n * @param {Schema<Target>} schema Structure-preserving object from a source data towards a target data\n * @param {Constructable<Target>} [type] Target Class Type\n */\nexport function toClassObject<Target>(schema: Schema<Target>, type: Constructable<Target>) {\n  const mapper = transformItems(schema, type);\n  return decorator(mapper);\n}\n\nconst morphismRegistry = new MorphismRegistry();\nconst morphismMixin: typeof morphism & any = morphism;\nmorphismMixin.register = (t: any, s: any) => morphismRegistry.register(t, s);\nmorphismMixin.map = (t: any, d: any) => morphismRegistry.map(t, d);\nmorphismMixin.getMapper = (t: any) => morphismRegistry.getMapper(t);\nmorphismMixin.setMapper = (t: any, s: any) => morphismRegistry.setMapper(t, s);\nmorphismMixin.deleteMapper = (t: any) => morphismRegistry.deleteMapper(t);\nmorphismMixin.mappers = morphismRegistry.mappers;\n\nconst Morphism: typeof morphism & IMorphismRegistry = morphismMixin;\n\nexport default Morphism;\n","export const aggregator = (paths: any, object: any) => {\n  return paths.reduce((delta: any, path: any) => {\n    return set(delta, path, get(object, path));\n  }, {});\n};\n\nexport function assignInWith(target: any, source: any, customizer?: (targetValue: any, sourceValue: any) => any) {\n  Object.entries(source).forEach(([field, value]) => {\n    if (customizer) {\n      target[field] = customizer(target[field], value);\n    } else {\n      target[field] = value;\n    }\n  });\n  return target;\n}\n\nexport function isUndefined(value: any) {\n  return value === undefined;\n}\n\nexport function isObject(value: any) {\n  const type = typeof value;\n  return value != null && (type === 'object' || type === 'function');\n}\n\nexport function isString(value: any): value is string {\n  return typeof value === 'string' || value instanceof String;\n}\n\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\nexport function set(object: object, path: string, value: any) {\n  path = path.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties\n  path = path.replace(/^\\./, ''); // strip a leading dot\n  const paths = path.split('.');\n  const lastProperty = paths.pop();\n  const finalValue = paths.reduceRight(\n    (finalObject, prop) => {\n      return { [prop]: finalObject };\n    },\n    { [lastProperty]: value }\n  );\n\n  return { ...object, ...finalValue };\n}\nexport function get(object: any, path: string) {\n  path = path.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties\n  path = path.replace(/^\\./, ''); // strip a leading dot\n  const a = path.split('.');\n  for (let i = 0, n = a.length; i < n; ++i) {\n    const k = a[i];\n    if (isObject(object) && k in object) {\n      object = object[k];\n    } else {\n      return;\n    }\n  }\n  return object;\n}\n\nexport function zipObject(props: string[], values: any[]) {\n  return props.reduce((prev, prop, i) => {\n    return { ...prev, [prop]: values[i] };\n  }, {});\n}\n"],"sourceRoot":""}